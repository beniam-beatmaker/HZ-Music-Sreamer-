<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hertz - Offline Mode</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { font-family: 'Segoe UI', Arial, sans-serif; background: #181818; color: #fff; margin: 0; }
    header { position: sticky; top: 0; background: #121212; padding: 1rem 2rem; display: flex; align-items: center; justify-content: space-between; z-index: 1000; box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
    .logo-btn { font-size: 1.7rem; font-weight: bold; color: #1db954; background: transparent; border: 2px solid #1db954; border-radius: 30px; padding: 0.4rem 1.6rem; text-decoration: none; letter-spacing: 2px; cursor: pointer; transition: background 0.2s, color 0.2s;}
    .logo-btn:hover, .logo-btn:focus { background: #1db954; color: #181818; outline: none;}
    nav { display: flex; gap: 1rem;}
    nav a { text-decoration: none; color: #fff; background: #282828; padding: 0.6rem 1.4rem; border-radius: 30px; font-weight: 500; transition: background 0.2s, color 0.2s; border: 2px solid transparent;}
    nav a:hover, nav a.active { background: #1db954; color: #181818; border-color: #1db954;}
    .mobile-menu-btn { display: none; background: none; border: 2px solid #1db954; color: #1db954; font-size: 1.5rem; padding: 0.5rem; border-radius: 8px; cursor: pointer; transition: all 0.2s; }
    .mobile-menu-btn:hover { background: #1db954; color: #181818; }
    .mobile-nav { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(18, 18, 18, 0.95); z-index: 1000; padding-top: 4rem; }
    .mobile-nav.active { display: flex; flex-direction: column; align-items: center; gap: 1.5rem; }
    .mobile-nav a { color: #fff; background: #282828; padding: 1rem 2rem; border-radius: 30px; font-weight: 500; text-decoration: none; font-size: 1.1rem; border: 2px solid transparent; transition: all 0.2s; }
    .mobile-nav a:hover, .mobile-nav a.active { background: #1db954; color: #181818; border-color: #1db954; }
    .mobile-nav .close-btn { position: absolute; top: 1rem; right: 2rem; background: none; border: none; color: #fff; font-size: 2rem; cursor: pointer; }
    .feature-container { max-width: 600px; margin: 3rem auto; background: #232526; padding: 2rem; border-radius: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.2);}
    h2 { margin-bottom: 1.5rem; }
    .desc { color: #b3b3b3; }
    .upload-section { margin-top: 2rem; }
    input[type="file"] { margin-top: 1rem; }
    .offline-list { margin-top: 2rem; }
    .track-title { font-weight: bold; }
    .search-bar { margin: 2rem 0 1rem 0; display: flex; gap: 1rem; }
    .search-bar input { flex: 1; padding: 0.7rem; border-radius: 20px; border: none; font-size: 1rem; }
    .search-bar button { padding: 0.7rem 1.5rem; border-radius: 20px; border: none; background: #1db954; color: #181818; font-weight: bold; cursor: pointer; transition: background 0.2s;}
    .search-bar button:hover { background: #17a74a; color: #fff;}
    .sticky-player { 
      position: fixed; 
      bottom: 0; 
      left: 0; 
      width: 100%; 
      background: #232526; 
      z-index: 1000; 
      box-shadow: 0 -2px 8px rgba(0,0,0,0.2); 
      display: flex; 
      align-items: center; 
      padding: 0.8rem 2rem; 
      flex-direction: column;
      gap: 0.4rem;
    }
    .sticky-player > div {
      margin: 0 !important;
      padding: 0 !important;
    }
    .player-controls { display: flex; align-items: center; gap: 0.8rem; margin: 0; padding: 0; }
    .player-btn { background: none; border: none; color: #1db954; font-size: 1.5rem; cursor: pointer; transition: color 0.2s; margin: 0; padding: 0.2rem;}
    .player-btn:hover { color: #fff; }
    .player-title { font-weight: bold; color: #fff; text-align: center; margin: 0; padding: 0; }
    .player-audio { width: 250px; }
    .player-loop.active, .player-shuffle.active { color: #fff700; }
    .offline-list { margin-top: 2rem; }
    .offline-track { margin-bottom: 1.2rem; }
    .offline-track .track-title { font-size: 1rem; }
    .offline-track .track-actions { margin-top: 0.3rem; }
    .offline-track .track-actions button { background: #1db954; color: #181818; border: none; border-radius: 20px; padding: 0.2rem 1rem; font-size: 0.95rem; cursor: pointer; margin-right: 0.5rem;}
    .offline-track .track-actions button:hover { background: #17a74a; color: #fff;}
    .spacer { height: 70px; }
    @media (max-width: 700px) {
      .sticky-player { flex-direction: column; align-items: center; padding: 0.6rem 0.8rem; gap: 0.3rem; }
      .player-controls { gap: 0.6rem; flex-wrap: wrap; justify-content: center; }
      .player-btn { font-size: 1.3rem; }
      #volumeRange { width: 80px; }
    }
    @media (max-width: 768px) { 
      nav { display: none; } 
      .mobile-menu-btn { display: block; }
      header { flex-wrap: wrap; padding: 1rem; }
    }

    /* Add this CSS inside your <style> tag in <head> */

    .playlist-container {
      margin-top: 0.5rem;
      border-top: 1px solid #232323;
      padding-top: 1rem;
    }

    .offline-track {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1rem;
      background: #181818;
      border-radius: 8px;
      padding: 0.7rem 1rem;
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
      transition: background 0.2s;
    }

    .offline-track:hover {
      background: #232526;
    }

    .offline-track .track-title {
      font-size: 1rem;
      font-weight: 600;
      color: #fff;
      margin-right: 1.2rem;
    }

    .offline-track .track-actions {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .offline-track .track-actions button {
      background: #1db954;
      color: #181818;
      border: none;
      border-radius: 20px;
      padding: 0.2rem 1rem;
      font-size: 0.95rem;
      cursor: pointer;
      margin-right: 0.5rem;
      transition: background 0.2s, color 0.2s;
    }

    .offline-track .track-actions button:hover {
      background: #17a74a;
      color: #fff;
    }

    .offline-track .like-btn {
      background: none;
      border: none;
      color: #ff4081;
      font-size: 1.3em;
      vertical-align: middle;
      cursor: pointer;
      margin-left: 0.3rem;
      transition: color 0.2s;
    }

    .offline-track input[type="checkbox"] {
      accent-color: #1db954;
      margin-right: 0.7rem;
      width: 1.1em;
      height: 1.1em;
    }

    .playlist-track-btn {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      background: #232526;
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 0.8rem 1.2rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
    }

    .playlist-track-btn:hover {
      background: #1db954 !important;
      color: #181818 !important;
    }

    .playlist-track-btn .like-btn:hover {
      color: #fff700 !important;
    }
  </style>
</head>
<body>
  <header>
    <a href="index.html" class="logo-btn" aria-label="Go to Hertz homepage">Hertz</a>
    <button class="mobile-menu-btn" onclick="toggleMobileMenu()" aria-label="Toggle mobile menu">‚ò∞</button>
    <nav>
      <a href="index.html">Home</a>
      <a href="online.html">Online</a>
      <a href="offline.html" class="active">Offline</a>
      <a href="playlists.html">Playlists</a>
      <a href="favorites.html">Favorites</a>
      <a href="liked.html">Liked</a>
      <a href="Account.html">Account</a>
      <a href="settings.html">Settings</a>
    </nav>
    <!-- Mobile Navigation -->
    <div class="mobile-nav" id="mobileNav">
      <button class="close-btn" onclick="toggleMobileMenu()">&times;</button>
      <a href="index.html">Home</a>
      <a href="online.html">Online</a>
      <a href="offline.html" class="active">Offline</a>
      <a href="playlists.html">Playlists</a>
      <a href="favorites.html">Favorites</a>
      <a href="liked.html">Liked</a>
      <a href="Account.html">Account</a>
      <a href="settings.html">Settings</a>
    </div>
  </header>
  <div class="spacer"></div>
  <div class="feature-container">
    <h2>Offline Mode</h2>
    <p class="desc">Upload and play your own music files locally (offline).</p>
    <div class="upload-section">
      <input type="file" id="offlineFiles" accept="audio/*" multiple>
      <div class="search-bar">
        <input type="text" id="searchInput" placeholder="Search your offline tracks...">
        <button onclick="searchOfflineTracks()">Search</button>
      </div>
      <div id="recommendations" style="margin-bottom:1rem;"></div>
      <div style="margin:1rem 0;display:flex;gap:1rem;">
        <button id="clearAllBtn" style="background:#d32f2f;color:#fff;padding:0.5rem 1rem;border:none;border-radius:5px;cursor:pointer;">Clear All Tracks</button>
        <button id="removeSelectedBtn" style="background:#b71c1c;color:#fff;padding:0.5rem 1rem;border:none;border-radius:5px;cursor:pointer;">Remove Selected</button>
        <button onclick="testStorage()" style="background:#ff9800;color:#fff;padding:0.5rem 1rem;border:none;border-radius:5px;cursor:pointer;">Test Storage</button>
      </div>
      <div class="offline-list" id="offlineList" style="margin-top:1.5rem;"></div>
    </div>
  </div>
  <div class="sticky-player" id="stickyPlayer" style="display:none;">
    <div id="lyricsDisplay" style="display:none; margin-bottom:0.7rem; width:100%; text-align:center; min-height:2.2em; color:#1db954; font-size:1.1em; font-weight:bold; letter-spacing:1px; transition:color 0.2s;"></div>
    
    <!-- Song Title - Row 1 -->
    <div style="width:100%; text-align:center;">
      <span class="player-title" id="playerTrackTitle" style="font-weight:bold;color:#fff;font-size:1.2rem;display:block;line-height:1.3;"></span>
    </div>
    
    <!-- Time Display - Row 2 -->
    <div style="display:flex;align-items:center;justify-content:center;width:100%;">
      <span id="currentTime" style="font-size:0.95em;color:#b3b3b3;margin-right:0.5rem;">0:00</span>
      <input type="range" id="progressBar" min="0" max="100" value="0" step="0.1" style="flex:1;max-width:300px;">
      <span id="duration" style="font-size:0.95em;color:#b3b3b3;margin-left:0.5rem;">0:00</span>
    </div>
    
    <!-- Player Controls - Row 3 -->
    <div style="display:flex;align-items:center;justify-content:center;width:100%;">
      <div class="player-controls">
        <button class="player-btn" id="prevBtn" title="Previous">&#9198;</button>
        <button class="player-btn" id="playPauseBtn" title="Play/Pause">&#9654;</button>
        <button class="player-btn" id="nextBtn" title="Next">&#9197;</button>
        <button class="player-btn player-loop" id="loopBtn" title="Loop">&#128257;</button>
        <button class="player-btn player-shuffle" id="shuffleBtn" title="Shuffle">&#128256;</button>
        <button class="player-btn" id="lyricsBtn" title="Show/Hide Lyrics" style="color:#1db954;font-size:1.3em;">&#119070;</button>
        <label for="volumeRange" style="margin-left:1rem;color:#b3b3b3;font-size:0.95em;">Volume</label>
        <input type="range" id="volumeRange" min="0" max="1" step="0.01" value="0.7" style="width:100px;">
        <button id="likeBtn" title="Like" style="background:none;border:none;cursor:pointer;font-size:1.7rem;color:#b3b3b3;transition:color 0.2s;margin-left:1rem;">&#10084;</button>
      </div>
    </div>
    <audio id="playerAudio" class="player-audio"></audio>
  </div>
  <script>
// --- Mobile Menu Toggle ---
function toggleMobileMenu() {
  const mobileNav = document.getElementById('mobileNav');
  mobileNav.classList.toggle('active');
}

// Global variables
let offlineTracks = [];
let filteredTracks = [];
let currentIndex = 0;
let isPlaying = false;
let isLoop = false;
let isShuffle = false;
let lyricsVisible = false;
let currentLyrics = [];
const lyricsData = {};

// DOM elements
const offlineFiles = document.getElementById('offlineFiles');
const offlineList = document.getElementById('offlineList');
const searchInput = document.getElementById('searchInput');
const stickyPlayer = document.getElementById('stickyPlayer');
const playerAudio = document.getElementById('playerAudio');
const playerTrackTitle = document.getElementById('playerTrackTitle');
const playPauseBtn = document.getElementById('playPauseBtn');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const loopBtn = document.getElementById('loopBtn');
const shuffleBtn = document.getElementById('shuffleBtn');
const volumeRange = document.getElementById('volumeRange');
const progressBar = document.getElementById('progressBar');
const currentTimeSpan = document.getElementById('currentTime');
const durationSpan = document.getElementById('duration');
const recommendationsDiv = document.getElementById('recommendations');
const lyricsBtn = document.getElementById('lyricsBtn');
const lyricsDisplay = document.getElementById('lyricsDisplay');
const likeBtn = document.getElementById('likeBtn');

// Enhanced status display with visual feedback
function showStatus(message, type = 'info') {
  console.log(`[${type.toUpperCase()}] ${message}`);
  
  // Remove existing status
  const existingStatus = document.getElementById('statusIndicator');
  if (existingStatus) existingStatus.remove();
  
  // Create new status indicator
  const statusDiv = document.createElement('div');
  statusDiv.id = 'statusIndicator';
  statusDiv.style.cssText = `
    position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 10000;
    background: ${type === 'error' ? '#d32f2f' : type === 'success' ? '#1db954' : '#ff9800'}; 
    color: #fff; padding: 1rem 2rem; border-radius: 8px; font-weight: bold;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3); animation: slideDown 0.3s ease-out;
  `;
  statusDiv.textContent = message;
  document.body.appendChild(statusDiv);
  
  // Auto remove after delay
  setTimeout(() => {
    if (statusDiv.parentNode) {
      statusDiv.style.animation = 'slideUp 0.3s ease-in';
      setTimeout(() => statusDiv.remove(), 300);
    }
  }, type === 'error' ? 6000 : 4000);
}

function showSuccessMessage(message) {
  showStatus(message, 'success');
}

// Add CSS animations
const style = document.createElement('style');
style.textContent = `
  @keyframes slideDown { from { transform: translateX(-50%) translateY(-100%); } to { transform: translateX(-50%) translateY(0); } }
  @keyframes slideUp { from { transform: translateX(-50%) translateY(0); } to { transform: translateX(-50%) translateY(-100%); } }
`;
document.head.appendChild(style);

// --- GUARANTEED PERMANENT STORAGE SYSTEM ---
function getTrackId(file) {
  // Create unique but consistent ID
  const nameHash = file.name.replace(/[^a-zA-Z0-9]/g, '_');
  return `track_${nameHash}_${file.size}_${file.lastModified}`;
}

// Enhanced file to base64 conversion with progress tracking
function fileToBase64(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = function(e) {
      const result = e.target.result;
      
      // Validate base64 result
      if (!result || !result.startsWith('data:audio/')) {
        reject(new Error('Invalid base64 conversion result'));
        return;
      }
      
      console.log(`‚úÖ File "${file.name}" converted to base64 (${(result.length/1024).toFixed(1)}KB)`);
      resolve(result);
    };
    
    reader.onerror = function(e) {
      console.error('‚ùå File conversion error:', e);
      reject(new Error(`Failed to convert ${file.name} to base64`));
    };
    
    reader.onprogress = function(e) {
      if (e.lengthComputable) {
        const percentComplete = (e.loaded / e.total) * 100;
        if (percentComplete % 25 === 0) { // Log every 25%
          console.log(`üì§ Converting ${file.name}: ${percentComplete.toFixed(0)}%`);
        }
      }
    };
    
    reader.readAsDataURL(file);
  });
}

// Convert base64 back to blob URL for playback
function base64ToBlob(base64, type) {
  try {
    const byteCharacters = atob(base64.split(',')[1]);
    const byteNumbers = new Array(byteCharacters.length);
    for (let i = 0; i < byteCharacters.length; i++) {
      byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    const byteArray = new Uint8Array(byteNumbers);
    const blob = new Blob([byteArray], { type });
    return URL.createObjectURL(blob);
  } catch (error) {
    console.error('Error converting base64 to blob:', error);
    return null;
  }
}

// GUARANTEED SAVE FUNCTION - Multiple redundant storage methods
function saveTracksToStorageGuaranteed() {
  return new Promise((resolve) => {
    try {
      console.log('üíæ STARTING GUARANTEED SAVE PROCESS...');
      showStatus('Saving tracks with multiple backup methods...', 'info');
      
      // Prepare data for storage
      const tracksData = {};
      let validTrackCount = 0;
      
      offlineTracks.forEach(track => {
        if (track.base64 && track.base64.startsWith('data:audio/')) {
          tracksData[track.id] = {
            id: track.id,
            name: track.name,
            artist: track.artist || 'Unknown Artist',
            cover: track.cover || 'https://placehold.co/120x120/1db954/fff?text=‚ô™',
            mp3: track.base64,
            type: track.type || 'audio/mpeg',
            size: track.size || 0,
            uploadDate: track.uploadDate || Date.now(),
            isLiked: track.isLiked || false,
            source: 'offline_app',
            version: '4.0',
            lastModified: Date.now()
          };
          validTrackCount++;
        }
      });
      
      console.log(`üíæ Prepared ${validTrackCount} tracks for guaranteed storage`);
      
      if (validTrackCount === 0) {
        showStatus('No valid tracks to save', 'error');
        resolve(false);
        return;
      }
      
      const dataString = JSON.stringify(tracksData);
      const dataSize = (dataString.length / 1024 / 1024).toFixed(2);
      console.log(`üìä Data size: ${dataSize}MB`);
      
      let saveSuccess = false;
      let successCount = 0;
      
      // Method 1: Primary localStorage save
      try {
        localStorage.setItem('hertzOfflineTracks', dataString);
        const verification1 = localStorage.getItem('hertzOfflineTracks');
        if (verification1 && JSON.parse(verification1)) {
          successCount++;
          console.log('‚úÖ Method 1: Primary localStorage - SUCCESS');
        }
      } catch (error) {
        console.error('‚ùå Method 1 failed:', error);
      }
      
      // Method 2: Backup localStorage
      try {
        localStorage.setItem('hertzOfflineTracks_backup', dataString);
        const verification2 = localStorage.getItem('hertzOfflineTracks_backup');
        if (verification2 && JSON.parse(verification2)) {
          successCount++;
          console.log('‚úÖ Method 2: Backup localStorage - SUCCESS');
        }
      } catch (error) {
        console.error('‚ùå Method 2 failed:', error);
      }
      
      // Method 3: Secondary backup
      try {
        localStorage.setItem('hertzOfflineTracks_emergency', dataString);
        const verification3 = localStorage.getItem('hertzOfflineTracks_emergency');
        if (verification3 && JSON.parse(verification3)) {
          successCount++;
          console.log('‚úÖ Method 3: Emergency backup - SUCCESS');
        }
      } catch (error) {
        console.error('‚ùå Method 3 failed:', error);
      }
      
      // Method 4: Metadata storage
      try {
        const metadata = {
          trackCount: validTrackCount,
          totalSize: dataString.length,
          lastSaved: Date.now(),
          version: '4.0',
          trackIds: Object.keys(tracksData)
        };
        localStorage.setItem('hertzOfflineTracksMetadata', JSON.stringify(metadata));
        successCount++;
        console.log('‚úÖ Method 4: Metadata storage - SUCCESS');
      } catch (error) {
        console.error('‚ùå Method 4 failed:', error);
      }
      
      // Method 5: IndexedDB save
      saveToIndexedDBGuaranteed(tracksData).then((idbSuccess) => {
        if (idbSuccess) {
          successCount++;
          console.log('‚úÖ Method 5: IndexedDB - SUCCESS');
        }
        
        // Final evaluation
        if (successCount >= 2) {
          saveSuccess = true;
          console.log(`üéâ GUARANTEED SAVE SUCCESS: ${successCount}/5 methods succeeded`);
          showSuccessMessage(`‚úÖ TRACKS PERMANENTLY SAVED (${successCount} backup methods)`);
          
          // Also save to liked storage for immediate availability
          saveLikedTracksForImmediateAccess(tracksData);
          
        } else {
          console.error(`‚ùå SAVE FAILED: Only ${successCount}/5 methods succeeded`);
          showStatus(`‚ùå Save failed: Only ${successCount} backup methods worked`, 'error');
        }
        
        resolve(saveSuccess);
      });
      
    } catch (error) {
      console.error('‚ùå Critical save error:', error);
      showStatus('‚ùå Critical save error: ' + error.message, 'error');
      resolve(false);
    }
  });
}

// Enhanced IndexedDB with guaranteed success
function saveToIndexedDBGuaranteed(tracksData) {
  return new Promise((resolve) => {
    try {
      console.log('üíæ Starting IndexedDB save...');
      
      const request = indexedDB.open('hertzOfflineTracksDB', 3);
      
      request.onupgradeneeded = function(e) {
        console.log('üîÑ Upgrading IndexedDB schema...');
        const db = e.target.result;
        
        // Delete old stores
        if (db.objectStoreNames.contains('tracks')) {
          db.deleteObjectStore('tracks');
        }
        
        // Create new store with enhanced schema
        const objectStore = db.createObjectStore('tracks', { keyPath: 'id' });
        objectStore.createIndex('name', 'name', { unique: false });
        objectStore.createIndex('artist', 'artist', { unique: false });
        objectStore.createIndex('isLiked', 'isLiked', { unique: false });
        objectStore.createIndex('uploadDate', 'uploadDate', { unique: false });
        
        console.log('‚úÖ IndexedDB schema updated');
      };
      
      request.onsuccess = function(e) {
        const db = e.target.result;
        const transaction = db.transaction(['tracks'], 'readwrite');
        const objectStore = transaction.objectStore('tracks');
        
        // Clear existing data
        const clearRequest = objectStore.clear();
        
        clearRequest.onsuccess = function() {
          console.log('üóëÔ∏è IndexedDB cleared, adding new tracks...');
          
          let savedCount = 0;
          const totalTracks = Object.values(tracksData).length;
          
          Object.values(tracksData).forEach(track => {
            const addRequest = objectStore.add(track);
            
            addRequest.onsuccess = function() {
              savedCount++;
              if (savedCount === totalTracks) {
                console.log(`‚úÖ IndexedDB: Successfully saved ${savedCount}/${totalTracks} tracks`);
                resolve(true);
              }
            };
            
            addRequest.onerror = function(e) {
              console.error('‚ùå IndexedDB add error for track:', track.name, e);
              // Continue with other tracks
            };
          });
          
          // Fallback timeout
          setTimeout(() => {
            if (savedCount > 0) {
              console.log(`‚ö†Ô∏è IndexedDB: Partial save ${savedCount}/${totalTracks} tracks`);
              resolve(savedCount > totalTracks * 0.5); // Consider success if >50% saved
            } else {
              resolve(false);
            }
          }, 10000);
        };
        
        clearRequest.onerror = function(e) {
          console.error('‚ùå IndexedDB clear error:', e);
          resolve(false);
        };
        
        transaction.onerror = function(e) {
          console.error('‚ùå IndexedDB transaction error:', e);
          resolve(false);
        };
      };
      
      request.onerror = function(e) {
        console.error('‚ùå IndexedDB open error:', e);
        resolve(false);
      };
      
      // Fallback timeout
      setTimeout(() => {
        console.warn('‚ö†Ô∏è IndexedDB save timeout');
        resolve(false);
      }, 15000);
      
    } catch (error) {
      console.error('‚ùå IndexedDB save exception:', error);
      resolve(false);
    }
  });
}

// Save liked tracks for immediate access in Liked App
function saveLikedTracksForImmediateAccess(allTracksData) {
  try {
    console.log('üíñ Saving liked tracks for immediate access...');
    
    let existingLiked = {};
    try {
      existingLiked = JSON.parse(localStorage.getItem('hertzLikedTracks') || '{}');
    } catch (e) {
      console.warn('‚ö†Ô∏è Error loading existing liked tracks, starting fresh');
    }
    
    // Add all tracks to liked storage (they can be filtered by isLiked flag)
    Object.values(allTracksData).forEach(track => {
      existingLiked[track.id] = {
        ...track,
        source: 'offline_app',
        syncedDate: Date.now()
      };
    });
    
    const likedDataString = JSON.stringify(existingLiked);
    
    // Save with multiple backups
    localStorage.setItem('hertzLikedTracks', likedDataString);
    localStorage.setItem('hertzLikedTracks_backup', likedDataString);
    localStorage.setItem('hertzLikedTracks_sync', likedDataString);
    
    // Trigger update for other tabs
    localStorage.setItem('hertzLikedTracksUpdate', Date.now().toString());
    
    console.log('‚úÖ All tracks synced to liked storage for immediate access');
    
  } catch (error) {
    console.error('‚ùå Error syncing to liked storage:', error);
  }
}

// --- ENHANCED FILE UPLOAD HANDLER WITH GUARANTEED SAVE ---
offlineFiles.addEventListener('change', async function() {
  const files = Array.from(this.files);
  if (files.length === 0) return;
  
  console.log('=== PROCESSING', files.length, 'FILES FOR PERMANENT STORAGE ===');
  showStatus(`Processing ${files.length} file(s) for permanent storage...`, 'info');
  
  const existingIds = new Set(offlineTracks.map(t => t.id));
  let successCount = 0;
  let errorCount = 0;
  
  // Process files sequentially to avoid overwhelming the system
  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    const id = getTrackId(file);
    
    try {
      // Check for duplicates
      if (existingIds.has(id)) {
        console.log(`‚ö†Ô∏è Skipping duplicate: ${file.name}`);
        continue;
      }
      
      // Validate file type
      if (!file.type.startsWith('audio/')) {
        console.warn(`‚ö†Ô∏è Skipping non-audio file: ${file.name}`);
        showStatus(`Skipped: ${file.name} (not an audio file)`, 'error');
        errorCount++;
        continue;
      }
      
      console.log(`üîÑ Processing [${i+1}/${files.length}]: ${file.name}`);
      showStatus(`Converting ${file.name} to permanent format... (${i+1}/${files.length})`, 'info');
      
      // Convert to base64 with validation
      const base64 = await fileToBase64(file);
      if (!base64 || !base64.startsWith('data:audio/')) {
        throw new Error('Base64 conversion failed or invalid format');
      }
      
      // Create playable URL for immediate use
      const url = URL.createObjectURL(file);
      
      // Create track object with all required data
      const track = {
        id: id,
        name: file.name.replace(/\.[^/.]+$/, ""), // Remove file extension
        artist: 'Unknown Artist',
        cover: 'https://placehold.co/120x120/1db954/fff?text=‚ô™',
        url: url,
        base64: base64,
        type: file.type,
        size: file.size,
        uploadDate: Date.now(),
        isLiked: false,
        source: 'offline_app',
        version: '4.0'
      };
      
      // Add to tracks array
      offlineTracks.push(track);
      existingIds.add(id);
      successCount++;
      
      console.log(`‚úÖ Added [${successCount}]: ${file.name} (${(file.size/1024/1024).toFixed(1)}MB)`);
      
      // Save immediately after each successful conversion (incremental save)
      if (successCount % 3 === 0 || i === files.length - 1) {
        console.log(`üíæ Incremental save triggered (${successCount} tracks)...`);
        const saveResult = await saveTracksToStorageGuaranteed();
        if (!saveResult) {
          console.warn(`‚ö†Ô∏è Incremental save failed for batch ending with: ${file.name}`);
        }
      }
      
    } catch (error) {
      console.error(`‚ùå Error processing ${file.name}:`, error);
      showStatus(`Error processing: ${file.name} - ${error.message}`, 'error');
      errorCount++;
    }
  }
  
  // Final processing
  console.log('=== PROCESSING COMPLETE ===');
  console.log(`‚úÖ Success: ${successCount} tracks`);
  console.log(`‚ùå Errors: ${errorCount} files`);
  
  if (successCount > 0) {
    // Sort tracks alphabetically
    offlineTracks.sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));
    filteredTracks = [...offlineTracks];
    
    // Final guaranteed save
    console.log('üíæ Final guaranteed save...');
    const finalSaveResult = await saveTracksToStorageGuaranteed();
    
    if (finalSaveResult) {
      showSuccessMessage(`üéâ ${successCount} track(s) PERMANENTLY SAVED & READY FOR PLAYBACK!`);
      
      // Verify save by checking storage
      setTimeout(() => {
        verifyStorageSave(successCount);
      }, 1000);
      
    } else {
      showStatus('‚ùå Final save verification failed', 'error');
    }
    
    // Update UI
    renderOfflineList(filteredTracks);
    
    // Show player if tracks exist
    if (offlineTracks.length > 0) {
      initializePlayer();
    }
  } else {
    showStatus('‚ùå No tracks were successfully processed', 'error');
  }
  
  if (errorCount > 0) {
    showStatus(`‚ö†Ô∏è ${errorCount} file(s) could not be processed`, 'error');
  }
  
  // Clear file input for next upload
  offlineFiles.value = '';
  console.log('=== UPLOAD SESSION COMPLETE ===');
});

// Verify that tracks were actually saved
function verifyStorageSave(expectedCount) {
  try {
    console.log('üîç Verifying storage save...');
    
    let verificationsPassed = 0;
    
    // Check primary storage
    const primary = localStorage.getItem('hertzOfflineTracks');
    if (primary) {
      const primaryData = JSON.parse(primary);
      const primaryCount = Object.keys(primaryData).length;
      if (primaryCount >= expectedCount) {
        verificationsPassed++;
        console.log(`‚úÖ Primary storage verified: ${primaryCount} tracks`);
      }
    }
    
    // Check backup storage
    const backup = localStorage.getItem('hertzOfflineTracks_backup');
    if (backup) {
      const backupData = JSON.parse(backup);
      const backupCount = Object.keys(backupData).length;
      if (backupCount >= expectedCount) {
        verificationsPassed++;
        console.log(`‚úÖ Backup storage verified: ${backupCount} tracks`);
      }
    }
    
    // Check liked storage sync
    const liked = localStorage.getItem('hertzLikedTracks');
    if (liked) {
      const likedData = JSON.parse(liked);
      const likedCount = Object.keys(likedData).length;
      if (likedCount >= expectedCount) {
        verificationsPassed++;
        console.log(`‚úÖ Liked storage sync verified: ${likedCount} tracks`);
      }
    }
    
    if (verificationsPassed >= 2) {
      console.log(`üéâ STORAGE VERIFICATION PASSED: ${verificationsPassed}/3 locations confirmed`);
      showSuccessMessage('‚úÖ PERMANENT STORAGE VERIFIED - TRACKS READY FOR PLAYBACK!');
    } else {
      console.warn(`‚ö†Ô∏è Storage verification concern: Only ${verificationsPassed}/3 locations confirmed`);
      showStatus('‚ö†Ô∏è Storage verification incomplete - may need manual save', 'error');
    }
    
  } catch (error) {
    console.error('‚ùå Storage verification error:', error);
    showStatus('‚ùå Storage verification failed', 'error');
  }
}

// --- ENHANCED TRACK LOADING FROM STORAGE ---
async function loadTracksFromStorageGuaranteed() {
  try {
    console.log('üìÇ STARTING ENHANCED TRACK LOADING...');
    showStatus('Loading permanently saved tracks...', 'info');
    
    let tracksData = {};
    let sourceUsed = 'none';
    
    // Method 1: Try primary storage
    console.log('üìÇ Method 1: Checking primary storage...');
    try {
      const primaryData = localStorage.getItem('hertzOfflineTracks');
      if (primaryData) {
        const parsed = JSON.parse(primaryData);
        if (Object.keys(parsed).length > 0) {
          tracksData = parsed;
          sourceUsed = 'hertzOfflineTracks';
          console.log(`‚úÖ Loaded ${Object.keys(tracksData).length} tracks from primary storage`);
        }
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Primary storage error:', error);
    }
    
    // Method 2: Try backup storage
    if (Object.keys(tracksData).length === 0) {
      console.log('üìÇ Method 2: Checking backup storage...');
      try {
        const backupData = localStorage.getItem('hertzOfflineTracks_backup');
        if (backupData) {
          const parsed = JSON.parse(backupData);
          if (Object.keys(parsed).length > 0) {
            tracksData = parsed;
            sourceUsed = 'hertzOfflineTracks_backup';
            console.log(`‚úÖ Loaded ${Object.keys(tracksData).length} tracks from backup storage`);
          }
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Backup storage error:', error);
      }
    }
    
    // Method 3: Try emergency storage
    if (Object.keys(tracksData).length === 0) {
      console.log('üìÇ Method 3: Checking emergency storage...');
      try {
        const emergencyData = localStorage.getItem('hertzOfflineTracks_emergency');
        if (emergencyData) {
          const parsed = JSON.parse(emergencyData);
          if (Object.keys(parsed).length > 0) {
            tracksData = parsed;
            sourceUsed = 'hertzOfflineTracks_emergency';
            console.log(`‚úÖ Loaded ${Object.keys(tracksData).length} tracks from emergency storage`);
          }
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Emergency storage error:', error);
      }
    }
    
    // Method 4: Try IndexedDB
    if (Object.keys(tracksData).length === 0) {
      console.log('üìÇ Method 4: Checking IndexedDB...');
      try {
        const idbTracks = await loadFromIndexedDB();
        if (idbTracks && Object.keys(idbTracks).length > 0) {
          tracksData = idbTracks;
          sourceUsed = 'IndexedDB';
          console.log(`‚úÖ Loaded ${Object.keys(tracksData).length} tracks from IndexedDB`);
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è IndexedDB error:', error);
      }
    }
    
    // Convert storage format back to playable tracks
    const restoredTracks = [];
    let validCount = 0;
    let invalidCount = 0;
    
    for (const trackData of Object.values(tracksData)) {
      try {
        if (trackData.mp3 && trackData.mp3.startsWith('data:audio/')) {
          const url = base64ToBlob(trackData.mp3, trackData.type || 'audio/mpeg');
          if (url) {
            restoredTracks.push({
              id: trackData.id,
              name: trackData.name,
              artist: trackData.artist || 'Unknown Artist',
              cover: trackData.cover || 'https://placehold.co/120x120/1db954/fff?text=‚ô™',
              url: url,
              base64: trackData.mp3,
              type: trackData.type,
              size: trackData.size,
              uploadDate: trackData.uploadDate,
              isLiked: trackData.isLiked || false,
              source: trackData.source || 'offline_app'
            });
            validCount++;
          } else {
            console.warn('‚ö†Ô∏è Failed to create blob URL for:', trackData.name);
            invalidCount++;
          }
        } else {
          console.warn('‚ö†Ô∏è Invalid MP3 data for:', trackData.name);
          invalidCount++;
        }
      } catch (error) {
        console.error('‚ùå Error processing track:', trackData.name, error);
        invalidCount++;
      }
    }
    
    console.log(`üìä Load Results: ${validCount} valid, ${invalidCount} invalid tracks`);
    console.log(`üìñ Source used: ${sourceUsed}`);
    
    if (validCount > 0) {
      showSuccessMessage(`‚úÖ Loaded ${validCount} tracks from ${sourceUsed}`);
    } else {
      showStatus('‚ÑπÔ∏è No valid tracks found in storage', 'info');
    }
    
    return restoredTracks;
    
  } catch (error) {
    console.error('‚ùå Critical loading error:', error);
    showStatus('‚ùå Error loading tracks: ' + error.message, 'error');
    return [];
  }
}

// Enhanced IndexedDB loading
function loadFromIndexedDB() {
  return new Promise((resolve) => {
    try {
      const request = indexedDB.open('hertzOfflineTracksDB', 3);
      
      request.onsuccess = function(e) {
        const db = e.target.result;
        const transaction = db.transaction(['tracks'], 'readonly');
        const objectStore = transaction.objectStore('tracks');
        const getAllRequest = objectStore.getAll();
        
        getAllRequest.onsuccess = function() {
          const tracks = getAllRequest.result;
          const tracksData = {};
          tracks.forEach(track => {
            tracksData[track.id] = track;
          });
          console.log(`üíæ IndexedDB returned ${tracks.length} tracks`);
          resolve(tracksData);
        };
        
        getAllRequest.onerror = function(e) {
          console.error('‚ùå IndexedDB getAll error:', e);
          resolve({});
        };
      };
      
      request.onerror = function(e) {
        console.error('‚ùå IndexedDB open error:', e);
        resolve({});
      };
      
      // Timeout fallback
      setTimeout(() => {
        console.warn('‚ö†Ô∏è IndexedDB load timeout');
        resolve({});
      }, 15000);
      
    } catch (error) {
      console.error('‚ùå IndexedDB load exception:', error);
      resolve({});
    }
  });
}

// --- ENHANCED PLAYER FUNCTIONS ---
function playTrack(index) {
  if (!filteredTracks[index]) {
    showStatus('Track not found', 'error');
    return;
  }
  
  const track = filteredTracks[index];
  currentIndex = index;
  
  console.log('üéµ Playing track:', track.name);
  showStatus(`Playing: ${track.name}`, 'success');
  
  // Set audio source
  if (track.url) {
    playerAudio.src = track.url;
  } else if (track.base64) {
    const blobUrl = base64ToBlob(track.base64, track.type);
    if (blobUrl) {
      playerAudio.src = blobUrl;
    } else {
      showStatus('Error creating playable audio', 'error');
      return;
    }
  } else {
    showStatus('No audio source available', 'error');
    return;
  }
  
  // Update UI
  playerTrackTitle.textContent = track.name;
  playPauseBtn.innerHTML = '&#10073;&#10073;';
  isPlaying = true;
  
  // Update like button
  updateLikeButton(track);
  
  // Show player
  stickyPlayer.style.display = 'flex';
  
  // Play audio
  playerAudio.play().catch(error => {
    console.error('‚ùå Playback error:', error);
    showStatus('Playback failed: ' + error.message, 'error');
  });
}

function playPause() {
  if (!filteredTracks[currentIndex]) {
    showStatus('No track selected', 'error');
    return;
  }
  
  if (isPlaying) {
    playerAudio.pause();
    playPauseBtn.innerHTML = '&#9654;';
    isPlaying = false;
  } else {
    playerAudio.play().then(() => {
      playPauseBtn.innerHTML = '&#10073;&#10073;';
      isPlaying = true;
    }).catch(error => {
      console.error('‚ùå Playback error:', error);
      showStatus('Playback failed: ' + error.message, 'error');
    });
  }
}

function playNext() {
  if (filteredTracks.length === 0) return;
  if (isShuffle) {
    currentIndex = Math.floor(Math.random() * filteredTracks.length);
  } else {
    currentIndex = (currentIndex + 1) % filteredTracks.length;
  }
  playTrack(currentIndex);
}

function playPrev() {
  if (filteredTracks.length === 0) return;
  if (isShuffle) {
    currentIndex = Math.floor(Math.random() * filteredTracks.length);
  } else {
    currentIndex = (currentIndex - 1 + filteredTracks.length) % filteredTracks.length;
  }
  playTrack(currentIndex);
}

function toggleLoop() {
  isLoop = !isLoop;
  playerAudio.loop = isLoop;
  loopBtn.classList.toggle('active', isLoop);
  console.log('üîÅ Loop:', isLoop ? 'ON' : 'OFF');
  showStatus(`Loop ${isLoop ? 'enabled' : 'disabled'}`, 'info');
}

function toggleShuffle() {
  isShuffle = !isShuffle;
  shuffleBtn.classList.toggle('active', isShuffle);
  console.log('üîÄ Shuffle:', isShuffle ? 'ON' : 'OFF');
  showStatus(`Shuffle ${isShuffle ? 'enabled' : 'disabled'}`, 'info');
}

// Enhanced like system with guaranteed sync
function toggleLike() {
  const track = filteredTracks[currentIndex];
  if (!track) return;
  
  track.isLiked = !track.isLiked;
  
  console.log(`üíñ Track "${track.name}" ${track.isLiked ? 'liked' : 'unliked'}`);
  
  // Update button
  updateLikeButton(track);
  
  // Save changes immediately
  saveTracksToStorageGuaranteed().then(() => {
    showStatus(`${track.isLiked ? '‚ô• Liked' : 'üíî Unliked'}: ${track.name}`, 'success');
  });
  
  // Update the main tracks array
  const mainTrackIndex = offlineTracks.findIndex(t => t.id === track.id);
  if (mainTrackIndex !== -1) {
    offlineTracks[mainTrackIndex].isLiked = track.isLiked;
  }
  
  // Refresh the UI
  renderOfflineList(filteredTracks);
}

function updateLikeButton(track) {
  if (!likeBtn) return;
  
  if (track.isLiked) {
    likeBtn.style.color = '#1db954';
    likeBtn.innerHTML = '‚ô•';
  } else {
    likeBtn.style.color = '#b3b3b3';
    likeBtn.innerHTML = '‚ô°';
  }
}

// Enhanced track rendering with like buttons
function renderOfflineList(tracks) {
  if (!offlineList) return;
  
  if (tracks.length === 0) {
    offlineList.innerHTML = '<p style="color: #b3b3b3; text-align: center; padding: 2rem;">No tracks uploaded yet. Upload some audio files to get started!</p>';
    return;
  }
  
  offlineList.innerHTML = tracks.map((track, index) => `
    <div class="offline-track" data-track-id="${track.id}">
      <input type="checkbox" id="track-${track.id}" onchange="updateRemoveButton()">
      <button class="playlist-track-btn" onclick="playTrack(${index})">
        <span class="track-title">${track.name}</span>
        <span class="like-btn" onclick="event.stopPropagation(); toggleTrackLike('${track.id}')" 
              style="color: ${track.isLiked ? '#1db954' : '#b3b3b3'}; cursor: pointer; font-size: 1.2rem;">
          ${track.isLiked ? '‚ô•' : '‚ô°'}
        </span>
      </button>
    </div>
  `).join('');
}

// Toggle like for individual tracks in the list
function toggleTrackLike(trackId) {
  const track = offlineTracks.find(t => t.id === trackId);
  if (!track) return;
  
  track.isLiked = !track.isLiked;
  
  console.log(`üíñ Track "${track.name}" ${track.isLiked ? 'liked' : 'unliked'}`);
  
  // Update filtered tracks if it contains this track
  const filteredTrack = filteredTracks.find(t => t.id === trackId);
  if (filteredTrack) {
    filteredTrack.isLiked = track.isLiked;
  }
  
  // Update current playing track if it's this one
  if (filteredTracks[currentIndex] && filteredTracks[currentIndex].id === trackId) {
    updateLikeButton(track);
  }
  
  // Save and refresh
  saveTracksToStorageGuaranteed().then(() => {
    showStatus(`${track.isLiked ? '‚ô• Liked' : 'üíî Unliked'}: ${track.name}`, 'success');
  });
  
  renderOfflineList(filteredTracks);
}

// Search functionality
function searchOfflineTracks() {
  const query = searchInput.value.toLowerCase().trim();
  
  if (query === '') {
    filteredTracks = [...offlineTracks];
  } else {
    filteredTracks = offlineTracks.filter(track => 
      track.name.toLowerCase().includes(query) || 
      track.artist.toLowerCase().includes(query)
    );
  }
  
  renderOfflineList(filteredTracks);
  
  if (filteredTracks.length === 0 && query !== '') {
    showStatus(`No tracks found for "${query}"`, 'info');
  } else if (query !== '') {
    showStatus(`Found ${filteredTracks.length} track(s) for "${query}"`, 'success');
  }
}

// Utility functions
function formatTime(sec) {
  if (isNaN(sec)) return '0:00';
  sec = Math.floor(sec);
  const m = Math.floor(sec / 60);
  const s = sec % 60;
  return m + ":" + (s < 10 ? "0" : "") + s;
}

function updateRemoveButton() {
  const checkboxes = document.querySelectorAll('#offlineList input[type="checkbox"]:checked');
  const removeBtn = document.getElementById('removeSelectedBtn');
  if (removeBtn) {
    removeBtn.textContent = `Remove Selected (${checkboxes.length})`;
    removeBtn.style.opacity = checkboxes.length > 0 ? '1' : '0.5';
  }
}

// Initialize player controls
function initializePlayer() {
  if (!stickyPlayer) return;
  
  console.log('üéÆ Initializing player controls...');
  
  // Player control event listeners
  if (playPauseBtn) playPauseBtn.onclick = playPause;
  if (prevBtn) prevBtn.onclick = playPrev;
  if (nextBtn) nextBtn.onclick = playNext;
  if (loopBtn) loopBtn.onclick = toggleLoop;
  if (shuffleBtn) shuffleBtn.onclick = toggleShuffle;
  if (likeBtn) likeBtn.onclick = toggleLike;
  
  // Audio event listeners
  if (playerAudio) {
    playerAudio.addEventListener('timeupdate', function() {
      if (playerAudio.duration) {
        const progress = (playerAudio.currentTime / playerAudio.duration) * 100;
        progressBar.value = progress;
        currentTimeSpan.textContent = formatTime(playerAudio.currentTime);
        durationSpan.textContent = formatTime(playerAudio.duration);
      }
    });
    
    playerAudio.addEventListener('ended', function() {
      if (isLoop) {
        playerAudio.currentTime = 0;
        playerAudio.play();
      } else {
        playNext();
      }
    });
    
    playerAudio.addEventListener('loadedmetadata', function() {
      if (durationSpan) {
        durationSpan.textContent = formatTime(playerAudio.duration);
      }
    });
    
    playerAudio.addEventListener('error', function(e) {
      console.error('‚ùå Audio error:', e);
      showStatus('Audio playback error', 'error');
    });
    
    // Set initial volume
    playerAudio.volume = 0.7;
  }
  
  // Progress bar control
  if (progressBar) {
    progressBar.addEventListener('input', function() {
      if (playerAudio.duration) {
        playerAudio.currentTime = (progressBar.value / 100) * playerAudio.duration;
      }
    });
  }
  
  // Volume control
  if (volumeRange) {
    volumeRange.addEventListener('input', function() {
      if (playerAudio) {
        playerAudio.volume = this.value;
      }
    });
    volumeRange.value = 0.7;
  }
  
  console.log('‚úÖ Player controls initialized');
}

// Storage test function
window.testStorage = function() {
  console.log('üß™ STORAGE TEST REPORT');
  console.log('='.repeat(50));
  
  const sources = [
    'hertzOfflineTracks',
    'hertzOfflineTracks_backup', 
    'hertzOfflineTracks_emergency',
    'hertzLikedTracks',
    'hertzLikedTracks_backup'
  ];
  
  sources.forEach(source => {
    try {
      const data = localStorage.getItem(source);
      if (data) {
        const parsed = JSON.parse(data);
        const trackCount = Object.keys(parsed).length;
        const sizeKB = (data.length / 1024).toFixed(1);
        console.log(`üìä ${source}: ${trackCount} tracks, ${sizeKB}KB`);
      } else {
        console.log(`üìä ${source}: Empty`);
      }
    } catch (error) {
      console.log(`üìä ${source}: Error - ${error.message}`);
    }
  });
  
  console.log('='.repeat(50));
  showStatus('Storage test completed - check console', 'info');
};

// Clear all tracks function
document.getElementById('clearAllBtn')?.addEventListener('click', function() {
  if (confirm('Are you sure you want to remove ALL tracks? This cannot be undone!')) {
    console.log('üóëÔ∏è Clearing all tracks...');
    
    // Clear arrays
    offlineTracks = [];
    filteredTracks = [];
    
    // Clear storage
    localStorage.removeItem('hertzOfflineTracks');
    localStorage.removeItem('hertzOfflineTracks_backup');
    localStorage.removeItem('hertzOfflineTracks_emergency');
    
    // Clear IndexedDB
    const deleteRequest = indexedDB.deleteDatabase('hertzOfflineTracksDB');
    deleteRequest.onsuccess = () => console.log('‚úÖ IndexedDB cleared');
    
    // Update UI
    renderOfflineList([]);
    stickyPlayer.style.display = 'none';
    
    showSuccessMessage('‚úÖ All tracks cleared successfully');
  }
});

// Remove selected tracks function
document.getElementById('removeSelectedBtn')?.addEventListener('click', function() {
  const checkboxes = document.querySelectorAll('#offlineList input[type="checkbox"]:checked');
  if (checkboxes.length === 0) {
    showStatus('No tracks selected for removal', 'error');
    return;
  }
  
  if (confirm(`Remove ${checkboxes.length} selected track(s)?`)) {
    const trackIdsToRemove = Array.from(checkboxes).map(cb => cb.id.replace('track-', ''));
    
    // Remove from arrays
    offlineTracks = offlineTracks.filter(track => !trackIdsToRemove.includes(track.id));
    filteredTracks = filteredTracks.filter(track => !trackIdsToRemove.includes(track.id));
    
    // Save updated data
    saveTracksToStorageGuaranteed().then(() => {
      renderOfflineList(filteredTracks);
      showSuccessMessage(`‚úÖ Removed ${checkboxes.length} track(s)`);
    });
  }
});

// Search input event listener
if (searchInput) {
  searchInput.addEventListener('input', searchOfflineTracks);
  searchInput.addEventListener('keyup', function(e) {
    if (e.key === 'Enter') {
      searchOfflineTracks();
    }
  });
}

// Cross-tab sync
window.addEventListener('storage', function(e) {
  if (e.key === 'hertzOfflineTracksUpdate') {
    console.log('üîÑ Tracks updated in another tab, refreshing...');
    showStatus('Tracks updated in another tab, refreshing...', 'info');
    setTimeout(loadAndDisplayTracks, 1000);
  }
});

// Enhanced load and display function
async function loadAndDisplayTracks() {
  try {
    console.log('üîÑ Loading and displaying tracks...');
    
    const loadedTracks = await loadTracksFromStorageGuaranteed();
    
    if (loadedTracks.length > 0) {
      offlineTracks = loadedTracks;
      filteredTracks = [...offlineTracks];
      
      // Sort alphabetically
      offlineTracks.sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));
      filteredTracks.sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));
      
      renderOfflineList(filteredTracks);
      initializePlayer();
      
      console.log(`‚úÖ Displayed ${loadedTracks.length} tracks`);
    } else {
      console.log('‚ÑπÔ∏è No tracks to display');
      renderOfflineList([]);
    }
    
  } catch (error) {
    console.error('‚ùå Error loading tracks:', error);
    showStatus('Error loading tracks: ' + error.message, 'error');
  }
}

// Page initialization
window.addEventListener('DOMContentLoaded', function() {
  console.log('=== OFFLINE APP INITIALIZED ===');
  showStatus('Initializing Offline App...', 'info');
  
  // Initialize player immediately
  initializePlayer();
  
  // Load tracks after a short delay
  setTimeout(() => {
    loadAndDisplayTracks();
  }, 500);
  
  console.log('‚úÖ Offline App ready for file uploads and playback');
});

// Auto-save on page unload
window.addEventListener('beforeunload', function() {
  if (offlineTracks.length > 0) {
    console.log('üíæ Auto-saving before page unload...');
    saveTracksToStorageGuaranteed();
  }
});

// Memory cleanup
window.addEventListener('beforeunload', function() {
  // Revoke blob URLs to prevent memory leaks
  offlineTracks.forEach(track => {
    if (track.url && track.url.startsWith('blob:')) {
      URL.revokeObjectURL(track.url);
    }
  });
});

console.log('üéµ Enhanced Offline App script loaded successfully');
</script>
</body>
</html>
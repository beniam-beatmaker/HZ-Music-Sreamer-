<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hertz - Liked Tracks</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: 'Segoe UI', Arial, sans-serif; background: #181818; color: #fff; min-height: 100vh; display: flex; flex-direction: column; }
    header { position: sticky; top: 0; background: #121212; padding: 1rem 2rem; display: flex; align-items: center; justify-content: space-between; box-shadow: 0 2px 8px rgba(0,0,0,0.2); z-index: 1000; }
    .logo-btn { display: inline-block; font-size: 1.7rem; font-weight: bold; color: #1db954; background: transparent; border: 2px solid #1db954; border-radius: 30px; padding: 0.4rem 1.6rem; text-decoration: none; letter-spacing: 2px; cursor: pointer; transition: background 0.2s, color 0.2s;}
    .logo-btn:hover, .logo-btn:focus { background: #1db954; color: #181818; outline: none;}
    nav { display: flex; gap: 1rem;}
    nav a { text-decoration: none; color: #fff; background: #282828; padding: 0.6rem 1.4rem; border-radius: 30px; font-weight: 500; transition: background 0.2s, color 0.2s; border: 2px solid transparent;}
    nav a:hover, nav a.active { background: #1db954; color: #181818; border-color: #1db954;}
    .mobile-menu-btn { display: none; background: none; border: 2px solid #1db954; color: #1db954; font-size: 1.5rem; padding: 0.5rem; border-radius: 8px; cursor: pointer; transition: all 0.2s; }
    .mobile-menu-btn:hover { background: #1db954; color: #181818; }
    .mobile-nav { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(18, 18, 18, 0.95); z-index: 1000; padding-top: 4rem; }
    .mobile-nav.active { display: flex; flex-direction: column; align-items: center; gap: 1.5rem; }
    .mobile-nav a { color: #fff; background: #282828; padding: 1rem 2rem; border-radius: 30px; font-weight: 500; text-decoration: none; font-size: 1.1rem; border: 2px solid transparent; transition: all 0.2s; }
    .mobile-nav a:hover, .mobile-nav a.active { background: #1db954; color: #181818; border-color: #1db954; }
    .mobile-nav .close-btn { position: absolute; top: 1rem; right: 2rem; background: none; border: none; color: #fff; font-size: 2rem; cursor: pointer; }
    .container { display: flex; flex: 1; min-height: 0;}
    aside { width: 220px; background: #121212; padding: 2rem 1rem; display: flex; flex-direction: column; gap: 1.5rem; border-right: 1px solid #232323;}
    aside h2 { font-size: 1.1rem; color: #b3b3b3; margin-bottom: 1rem; letter-spacing: 1px;}
    aside ul { list-style: none; display: flex; flex-direction: column; gap: 1rem;}
    aside ul li a { color: #b3b3b3; text-decoration: none; font-size: 1rem; transition: color 0.2s;}
    aside ul li a:hover { color: #1db954;}
    main { flex: 1; padding: 2rem; overflow-y: auto; }
    h2 { margin-bottom: 1.5rem; }
    .desc { color: #b3b3b3; font-size: 1.1rem; margin-bottom: 1.5rem;}
    .liked-list { margin-top: 2rem; }
    .track-title { font-weight: bold; }
    .liked-track { margin-bottom: 1.2rem; }
    .liked-track .track-title { font-size: 1rem; }
    .liked-track .track-actions { margin-top: 0.3rem; }
    .liked-track .track-actions button { background: #1db954; color: #181818; border: none; border-radius: 20px; padding: 0.2rem 1rem; font-size: 0.95rem; cursor: pointer; margin-right: 0.5rem;}
    .liked-track .track-actions button:hover { background: #17a74a; color: #fff;}
    .sticky-player { 
      position: fixed; 
      bottom: 0; 
      left: 0; 
      width: 100%; 
      background: #232526; 
      z-index: 1000; 
      box-shadow: 0 -2px 8px rgba(0,0,0,0.2); 
      display: flex; 
      align-items: center; 
      padding: 0.5rem 2rem;
    }
    .player-controls { display: flex; align-items: center; gap: 1rem; }
    .player-btn { background: none; border: none; color: #1db954; font-size: 1.5rem; cursor: pointer; transition: color 0.2s;}
    .player-btn:hover { color: #fff; }
    .player-title { margin-left: 1.5rem; font-weight: bold; color: #fff; min-width: 120px; }
    .player-audio { width: 250px; margin-left: 1.5rem; }
    .player-loop.active, .player-shuffle.active { color: #fff700; }
    .spacer { height: 70px; }
    @media (max-width: 900px) { aside { display: none; } .container { flex-direction: column; } main { border-radius: 0; } }
    @media (max-width: 768px) { 
      nav { display: none; } 
      .mobile-menu-btn { display: block; }
      header { flex-wrap: wrap; padding: 1rem; }
    }
    @media (max-width: 700px) {
      .sticky-player { flex-direction: column; align-items: flex-start; padding: 0.5rem 0.5rem; }
      .player-title, .player-audio { margin-left: 0; }
    }
    @media (max-width: 600px) { header { flex-direction: column; gap: 1rem; } main { padding: 1rem; } }

    /* Suggestion box styles */
    #likedSuggestionBox {
      position: absolute;
      background: #232526;
      color: #fff;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      z-index: 1001;
      width: 240px;
      max-width: 400px;
      max-height: 300px;
      overflow-y: auto;
      font-size: 1rem;
      display: none;
    }
    .liked-suggestion-item {
      padding: 0.7rem 1rem;
      cursor: pointer;
      border-bottom: 1px solid #232323;
    }
    .liked-suggestion-item:last-child {
      border-bottom: none;
    }
    .liked-suggestion-item.active, .liked-suggestion-item:hover {
      background: #1db954;
      color: #181818;
    }

    /* Track card styles */
    .track-card {
      background: #232526;
      border-radius: 12px;
      padding: 1rem;
      text-align: center;
      transition: all 0.2s;
      cursor: pointer;
      width: 180px;
      margin: 0.5rem;
    }
    
    .track-card:hover {
      background: #282828;
      transform: translateY(-2px);
      box-shadow: 0 4px 16px rgba(0,0,0,0.3);
    }
    
    .track-card img {
      width: 120px;
      height: 120px;
      border-radius: 8px;
      object-fit: cover;
      margin-bottom: 0.8rem;
      cursor: pointer;
    }
    
    .play-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(29, 185, 84, 0.9);
      border-radius: 50%;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.2s;
      font-size: 1.5rem;
      color: #181818;
    }
    
    .track-card:hover .play-overlay {
      opacity: 1;
    }
    
    .track-name {
      font-weight: 600;
      color: #fff;
      font-size: 0.95rem;
      margin-bottom: 0.3rem;
      line-height: 1.2;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .track-artist {
      color: #b3b3b3;
      font-size: 0.85rem;
      margin-bottom: 0.8rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .track-actions {
      display: flex;
      gap: 0.5rem;
      justify-content: center;
      align-items: center;
    }
    
    .play-btn, .unlike-btn {
      background: #1db954;
      color: #181818;
      border: none;
      border-radius: 20px;
      padding: 0.4rem 0.8rem;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .unlike-btn {
      background: #d32f2f;
      color: #fff;
    }
    
    .play-btn:hover {
      background: #17a74a;
      color: #fff;
    }
    
    .unlike-btn:hover {
      background: #b71c1c;
    }

    #likedTracksContainer {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      justify-content: flex-start;
      padding: 1rem;
    }

    #emptyState {
      text-align: center;
      padding: 3rem;
      color: #b3b3b3;
    }

    .sticky-player {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background: #232526;
      z-index: 1000;
      box-shadow: 0 -2px 8px rgba(0,0,0,0.2);
      display: none;
      flex-direction: column;
      align-items: center;
      padding: 0.8rem 2rem;
      gap: 0.4rem;
    }

    .player-controls {
      display: flex;
      align-items: center;
      gap: 0.8rem;
    }

    .player-btn {
      background: none;
      border: none;
      color: #1db954;
      font-size: 1.5rem;
      cursor: pointer;
      transition: color 0.2s;
    }

    .player-btn:hover {
      color: #fff;
    }

    .player-btn.active {
      color: #fff700;
    }

    .player-title {
      font-weight: bold;
      color: #fff;
      text-align: center;
      margin: 0.5rem 0;
    }

    #progressBar {
      width: 250px;
      accent-color: #1db954;
    }

    #volumeRange {
      width: 100px;
      accent-color: #1db954;
    }
  </style>
</head>
<body>
  <header>
    <a href="index.html" class="logo-btn" aria-label="Go to Hertz homepage">Hertz</a>
    <button class="mobile-menu-btn" onclick="toggleMobileMenu()" aria-label="Toggle mobile menu">☰</button>
    <nav style="display:flex;align-items:center;gap:1rem;">
      <a href="index.html">Home</a>
      <a href="online.html">Online</a>
      <a href="Offline App.html">Offline</a>
      <a href="playlists.html">Playlists</a>
      <a href="favorites.html">Favorites</a>
      <a href="liked.html" class="active">Liked</a>
      <a href="Account.html">Account</a>
      <a href="settings.html">Settings</a>
      <!-- Liked search bar aligned with Settings button -->
      <div class="search-bar" style="display:flex;align-items:center;gap:1rem;margin-left:0.5rem;height:100%;">
        <input type="text" id="likedSearchInput" placeholder="Search your liked..." style="flex:1; padding:0.7rem; border-radius:20px; border:none; font-size:1rem; width:180px;">
        <button id="likedSearchBtn" style="padding:0.7rem 1.5rem; border-radius:20px; border:none; background:#1db954; color:#181818; font-weight:bold; cursor:pointer; transition:background 0.2s;">Search</button>
      </div>
    </nav>
    <!-- Mobile Navigation -->
    <div class="mobile-nav" id="mobileNav">
      <button class="close-btn" onclick="toggleMobileMenu()">&times;</button>
      <a href="index.html">Home</a>
      <a href="online.html">Online</a>
      <a href="Offline App.html">Offline</a>
      <a href="playlists.html">Playlists</a>
      <a href="favorites.html">Favorites</a>
      <a href="liked.html" class="active">Liked</a>
      <a href="Account.html">Account</a>
      <a href="settings.html">Settings</a>
    </div>
  </header>
  <div class="container">
    <aside>
      <h2>Browse</h2>
      <ul>
        <li><a href="online.html">Online Streaming</a></li>
        <li><a href="Offline App.html">Offline Mode</a></li>
        <li><a href="playlists.html">Playlists</a></li>
        <li><a href="favorites.html">Favorites</a></li>
        <li><a href="liked.html">Liked</a></li>
        <li><a href="Account.html">Account</a></li>
        <li><a href="settings.html">Settings</a></li>
      </ul>
    </aside>
    <main style="flex: 1; padding: 2rem; overflow-y: auto;">
      <h1 style="font-size: 2.5rem; font-weight: 700; margin-bottom: 1rem; color: #fff;">Liked Songs</h1>
      <p style="color: #b3b3b3; margin-bottom: 2rem;">Songs you've liked from the Offline App will appear here</p>
      
      <div id="likedTracksContainer"></div>
      <div id="emptyState" style="display: none;"></div>
    </main>
  </div>

  <!-- Sticky Player -->
  <div class="sticky-player" id="stickyPlayer">
    <!-- Song Title -->
    <div style="width: 100%; text-align: center;">
      <span class="player-title" id="playerTrackTitle">No track selected</span>
    </div>
    
    <!-- Time Display -->
    <div style="display: flex; align-items: center; justify-content: center; width: 100%;">
      <span id="currentTime" style="font-size: 0.9rem; color: #b3b3b3; margin-right: 0.5rem;">0:00</span>
      <input type="range" id="progressBar" min="0" max="100" value="0" step="0.1">
      <span id="duration" style="font-size: 0.9rem; color: #b3b3b3; margin-left: 0.5rem;">0:00</span>
    </div>
    
    <!-- Player Controls -->
    <div class="player-controls">
      <button class="player-btn" id="prevBtn" title="Previous">&#9198;</button>
      <button class="player-btn" id="playPauseBtn" title="Play/Pause">&#9654;</button>
      <button class="player-btn" id="nextBtn" title="Next">&#9197;</button>
      <button class="player-btn" id="loopBtn" title="Loop">&#128257;</button>
      <button class="player-btn" id="shuffleBtn" title="Shuffle">&#128256;</button>
      <label for="volumeRange" style="margin-left: 1rem; color: #b3b3b3; font-size: 0.9rem;">Volume</label>
      <input type="range" id="volumeRange" min="0" max="1" step="0.01" value="0.7">
      <button id="likeBtn" title="Liked" style="background: none; border: none; cursor: pointer; font-size: 1.7rem; color: #1db954; margin-left: 1rem;">♥</button>
    </div>
    
    <audio id="playerAudio"></audio>
  </div>

  <script>
// Global variables
let allTracks = [];
let currentIndex = 0;
let isPlaying = false;
let isLoop = false;
let isShuffle = false;

// DOM elements
const playerAudio = document.getElementById('playerAudio');
const playerTrackTitle = document.getElementById('playerTrackTitle');
const playPauseBtn = document.getElementById('playPauseBtn');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const loopBtn = document.getElementById('loopBtn');
const shuffleBtn = document.getElementById('shuffleBtn');
const volumeRange = document.getElementById('volumeRange');
const progressBar = document.getElementById('progressBar');
const currentTimeSpan = document.getElementById('currentTime');
const durationSpan = document.getElementById('duration');
const likeBtn = document.getElementById('likeBtn');

// Enhanced status display function
function showStatus(message, type = 'info') {
  console.log(`[${type.toUpperCase()}] ${message}`);
  
  const existingStatus = document.getElementById('statusIndicator');
  if (existingStatus) existingStatus.remove();
  
  const statusDiv = document.createElement('div');
  statusDiv.id = 'statusIndicator';
  statusDiv.style.cssText = `
    position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 10000;
    background: ${type === 'error' ? '#d32f2f' : type === 'success' ? '#1db954' : '#ff9800'}; 
    color: #fff; padding: 1rem 2rem; border-radius: 8px; font-weight: bold;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  `;
  statusDiv.textContent = message;
  document.body.appendChild(statusDiv);
  
  setTimeout(() => statusDiv.remove(), 4000);
}

// Enhanced base64 to blob conversion with comprehensive validation
function base64ToBlob(base64, type = 'audio/mpeg') {
  try {
    console.log('🔄 Converting base64 to blob...');
    
    if (!base64) {
      throw new Error('No base64 data provided');
    }
    
    if (!base64.includes('data:audio/')) {
      throw new Error('Invalid base64 format - not audio data');
    }
    
    if (!base64.includes(',')) {
      throw new Error('Invalid base64 format - missing comma separator');
    }
    
    const base64Data = base64.split(',')[1];
    if (!base64Data) {
      throw new Error('No base64 content after comma');
    }
    
    console.log('📊 Base64 data length:', base64Data.length);
    
    const byteCharacters = atob(base64Data);
    const byteNumbers = new Array(byteCharacters.length);
    
    for (let i = 0; i < byteCharacters.length; i++) {
      byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    
    const byteArray = new Uint8Array(byteNumbers);
    const blob = new Blob([byteArray], { type });
    const url = URL.createObjectURL(blob);
    
    console.log('✅ Successfully created blob URL:', url.substring(0, 50) + '...');
    console.log('📊 Blob size:', blob.size, 'bytes');
    
    return url;
  } catch (error) {
    console.error('❌ Error converting base64 to blob:', error);
    showStatus('Error converting audio data: ' + error.message, 'error');
    return null;
  }
}

// Enhanced track loading with comprehensive fallback system
async function loadSyncedLikedTracks() {
  try {
    console.log('🎵 Starting comprehensive track loading...');
    showStatus('Loading liked tracks from all sources...', 'info');
    
    let tracks = [];
    let sourceUsed = 'none';
    
    // Method 1: Load from primary liked tracks storage
    console.log('📂 Method 1: Checking primary liked tracks storage...');
    try {
      const likedTracksData = JSON.parse(localStorage.getItem('hertzLikedTracks') || '{}');
      const primaryTracks = Object.values(likedTracksData).filter(track => track.mp3 && track.mp3.startsWith('data:audio'));
      
      if (primaryTracks.length > 0) {
        tracks = primaryTracks;
        sourceUsed = 'hertzLikedTracks';
        console.log(`✅ Found ${tracks.length} tracks in primary liked storage`);
      }
    } catch (error) {
      console.warn('⚠️ Error loading from primary liked storage:', error);
    }
    
    // Method 2: Load from liked tracks backup
    if (tracks.length === 0) {
      console.log('📂 Method 2: Checking liked tracks backup...');
      try {
        const backupData = JSON.parse(localStorage.getItem('hertzLikedTracks_backup') || '{}');
        const backupTracks = Object.values(backupData).filter(track => track.mp3 && track.mp3.startsWith('data:audio'));
        
        if (backupTracks.length > 0) {
          tracks = backupTracks;
          sourceUsed = 'hertzLikedTracks_backup';
          console.log(`✅ Found ${tracks.length} tracks in liked backup storage`);
        }
      } catch (error) {
        console.warn('⚠️ Error loading from liked backup:', error);
      }
    }
    
    // Method 3: Scan offline tracks for liked ones
    if (tracks.length === 0) {
      console.log('📂 Method 3: Scanning offline tracks for liked ones...');
      try {
        const allOfflineTracks = JSON.parse(localStorage.getItem('hertzOfflineTracks') || '{}');
        const likedOfflineTracks = Object.values(allOfflineTracks).filter(track => 
          track.isLiked && track.mp3 && track.mp3.startsWith('data:audio')
        );
        
        if (likedOfflineTracks.length > 0) {
          tracks = likedOfflineTracks;
          sourceUsed = 'hertzOfflineTracks (liked)';
          console.log(`✅ Found ${tracks.length} liked tracks in offline storage`);
          
          // Sync them to liked storage for future use
          const likedData = {};
          tracks.forEach(track => {
            likedData[track.id] = {
              ...track,
              likedDate: Date.now(),
              source: 'offline_app'
            };
          });
          localStorage.setItem('hertzLikedTracks', JSON.stringify(likedData));
          localStorage.setItem('hertzLikedTracks_backup', JSON.stringify(likedData));
          console.log('🔄 Synced liked tracks to liked storage');
        }
      } catch (error) {
        console.warn('⚠️ Error scanning offline tracks:', error);
      }
    }
    
    // Method 4: Check all backup sources
    if (tracks.length === 0) {
      console.log('📂 Method 4: Checking all backup sources...');
      const backupSources = [
        'hertzOfflineTracks_backup',
        'hertzOfflineTracks_auto_backup',
        'hertzOfflineTracks_exit_backup'
      ];
      
      for (const source of backupSources) {
        try {
          const backupData = JSON.parse(localStorage.getItem(source) || '{}');
          const backupTracks = Object.values(backupData).filter(track => 
            track.isLiked && track.mp3 && track.mp3.startsWith('data:audio')
          );
          
          if (backupTracks.length > 0) {
            tracks = backupTracks;
            sourceUsed = source;
            console.log(`✅ Found ${tracks.length} tracks in ${source}`);
            break;
          }
        } catch (error) {
          console.warn(`⚠️ Error loading from ${source}:`, error);
        }
      }
    }
    
    console.log(`📖 Final result: ${tracks.length} tracks from ${sourceUsed}`);
    
    if (tracks.length > 0) {
      showStatus(`Found ${tracks.length} liked tracks from ${sourceUsed}`, 'success');
    } else {
      showStatus('No liked tracks found in any storage location', 'info');
    }
    
    return tracks;
    
  } catch (error) {
    console.error('❌ Error in loadSyncedLikedTracks:', error);
    showStatus('Error loading tracks: ' + error.message, 'error');
    return [];
  }
}

// Enhanced track validation and repair
function validateAndRepairTrack(track, index) {
  console.log(`🔍 Validating track ${index + 1}: ${track.name}`);
  
  // Check for required fields
  if (!track.id) {
    track.id = `track_${Date.now()}_${index}`;
    console.log('🔧 Added missing ID:', track.id);
  }
  
  if (!track.name) {
    track.name = `Unknown Track ${index + 1}`;
    console.log('🔧 Added missing name:', track.name);
  }
  
  if (!track.artist) {
    track.artist = 'Unknown Artist';
    console.log('🔧 Added missing artist');
  }
  
  if (!track.cover) {
    track.cover = 'https://placehold.co/120x120/1db954/fff?text=♪';
    console.log('🔧 Added default cover');
  }
  
  // Critical MP3 validation
  if (!track.mp3) {
    console.error('❌ Track missing MP3 data:', track.name);
    return null;
  }
  
  if (!track.mp3.startsWith('data:audio/')) {
    console.error('❌ Invalid MP3 format:', track.name, 'Format:', track.mp3.substring(0, 20));
    return null;
  }
  
  // Test base64 conversion
  const testUrl = base64ToBlob(track.mp3, track.type || 'audio/mpeg');
  if (!testUrl) {
    console.error('❌ Failed to convert MP3 data for:', track.name);
    return null;
  }
  
  // Clean up test URL
  URL.revokeObjectURL(testUrl);
  
  console.log('✅ Track validation passed:', track.name);
  
  return {
    id: track.id,
    name: track.name,
    artist: track.artist,
    cover: track.cover,
    mp3: track.mp3,
    type: track.type || 'audio/mpeg',
    size: track.size || 0,
    isLiked: track.isLiked !== false,
    likedDate: track.likedDate || Date.now(),
    source: track.source || 'offline_app'
  };
}

// Enhanced track rendering
async function renderLikedTracks() {
  console.log('🎵 Starting track rendering process...');
  
  let rawTracks = await loadSyncedLikedTracks();
  
  if (rawTracks.length === 0) {
    renderEmptyState();
    return;
  }
  
  console.log('🔍 Validating and repairing tracks...');
  showStatus('Validating track data...', 'info');
  
  // Validate and repair tracks
  const validTracks = [];
  for (let i = 0; i < rawTracks.length; i++) {
    const track = rawTracks[i];
    const validatedTrack = validateAndRepairTrack(track, i);
    if (validatedTrack) {
      validTracks.push(validatedTrack);
    }
  }
  
  if (validTracks.length === 0) {
    console.warn('⚠️ No valid tracks after validation');
    renderEmptyState('Found tracks but they have invalid audio data');
    return;
  }
  
  console.log(`✅ ${validTracks.length}/${rawTracks.length} tracks passed validation`);
  
  const container = document.getElementById('likedTracksContainer');
  const emptyState = document.getElementById('emptyState');
  
  emptyState.style.display = 'none';
  allTracks = validTracks;
  
  // Render track cards
  container.innerHTML = validTracks.map((track, index) => `
    <div class="track-card" data-track-id="${track.id}">
      <div style="position: relative;">
        <img src="${track.cover}" 
             alt="${track.name}" 
             onclick="playTrack(${index})"
             onerror="this.src='https://placehold.co/120x120/1db954/fff?text=♪'">
        <div class="play-overlay">
          <span>▶</span>
        </div>
      </div>
      <div class="track-name" title="${track.name}">${track.name}</div>
      <div class="track-artist" title="${track.artist}">${track.artist}</div>
      <div class="track-actions">
        <button class="play-btn" onclick="playTrack(${index})">🎵 Play</button>
        <button class="unlike-btn" onclick="unlikeTrack('${track.id}')" title="Remove from liked">💔</button>
      </div>
      <div style="font-size: 0.8rem; color: #666; margin-top: 0.5rem; text-align: center;">
        Size: ${track.size ? (track.size/1024/1024).toFixed(1) + 'MB' : 'Unknown'} | From: ${track.source || 'Offline App'}
      </div>
    </div>
  `).join('');
  
  console.log('✅ Rendered', validTracks.length, 'track cards');
  showStatus(`Successfully loaded ${validTracks.length} liked tracks`, 'success');
  
  // Save the validated tracks back to storage for future use
  const likedData = {};
  validTracks.forEach(track => {
    likedData[track.id] = track;
  });
  localStorage.setItem('hertzLikedTracks', JSON.stringify(likedData));
  localStorage.setItem('hertzLikedTracks_backup', JSON.stringify(likedData));
}

// Render empty state
function renderEmptyState(customMessage = null) {
  const container = document.getElementById('likedTracksContainer');
  const emptyState = document.getElementById('emptyState');
  
  container.innerHTML = '';
  emptyState.style.display = 'block';
  emptyState.innerHTML = `
    <div style="font-size: 3rem; margin-bottom: 1rem;">🎵</div>
    <h3 style="color: #b3b3b3; margin-bottom: 1rem;">
      ${customMessage || 'No liked tracks found'}
    </h3>
    <p style="color: #666;">
      ${customMessage ? 'Try going to the Offline App and uploading some tracks, then like them.' : 
        'Go to <a href="Offline App.html" style="color: #1db954;">Offline App</a> and like some tracks to see them here!'}
      <br><br>
      <button onclick="forceRescanTracks()" style="background: #1db954; color: #181818; border: none; padding: 0.5rem 1rem; border-radius: 20px; cursor: pointer; margin-top: 1rem;">
        🔄 Rescan for Tracks
      </button>
      <button onclick="debugStorage()" style="background: #ff9800; color: #fff; border: none; padding: 0.5rem 1rem; border-radius: 20px; cursor: pointer; margin-top: 1rem; margin-left: 0.5rem;">
        🐛 Debug Storage
      </button>
    </p>
  `;
}

// Enhanced play track function with comprehensive error handling
function playTrack(index) {
  if (!allTracks[index]) {
    showStatus('Track not found', 'error');
    return;
  }
  
  const track = allTracks[index];
  currentIndex = index;
  
  console.log('🎵 Attempting to play track:', track.name);
  showStatus(`Loading ${track.name}...`, 'info');
  
  try {
    // Convert base64 to playable URL with validation
    console.log('🔄 Converting base64 to playable URL...');
    const audioUrl = base64ToBlob(track.mp3, track.type || 'audio/mpeg');
    
    if (!audioUrl) {
      throw new Error('Failed to convert audio data to playable format');
    }
    
    console.log('✅ Audio URL created successfully');
    
    // Show sticky player
    const stickyPlayer = document.getElementById('stickyPlayer');
    stickyPlayer.style.display = 'flex';
    
    // Update player UI
    playerTrackTitle.textContent = track.name;
    playPauseBtn.innerHTML = '&#9654;';
    isPlaying = false;
    progressBar.value = 0;
    currentTimeSpan.textContent = '0:00';
    durationSpan.textContent = '0:00';
    
    // Update like button (always liked since this is liked tracks page)
    if (likeBtn) {
      likeBtn.style.color = '#1db954';
      likeBtn.innerHTML = '♥';
    }
    
    // Set up audio with error handling
    playerAudio.src = audioUrl;
    
    // Audio event listeners for this track
    const onLoadedMetadata = () => {
      console.log('✅ Audio metadata loaded, duration:', playerAudio.duration);
      durationSpan.textContent = formatTime(playerAudio.duration || 0);
      showStatus(`Ready to play: ${track.name}`, 'success');
    };
    
    const onError = (e) => {
      console.error('❌ Audio error:', e);
      showStatus(`Cannot play ${track.name}: Audio error`, 'error');
      playerAudio.removeEventListener('loadedmetadata', onLoadedMetadata);
      playerAudio.removeEventListener('error', onError);
      URL.revokeObjectURL(audioUrl);
    };
    
    const onLoadStart = () => {
      console.log('🔄 Audio loading started...');
    };
    
    const onCanPlay = () => {
      console.log('✅ Audio can start playing');
    };
    
    // Add event listeners
    playerAudio.addEventListener('loadedmetadata', onLoadedMetadata, { once: true });
    playerAudio.addEventListener('error', onError, { once: true });
    playerAudio.addEventListener('loadstart', onLoadStart, { once: true });
    playerAudio.addEventListener('canplay', onCanPlay, { once: true });
    
    // Start loading
    playerAudio.load();
    
    // Auto-play after a short delay
    setTimeout(() => {
      playPause();
    }, 500);
    
  } catch (error) {
    console.error('❌ Error in playTrack:', error);
    showStatus(`Cannot play track: ${error.message}`, 'error');
  }
}

// Enhanced unlike function
function unlikeTrack(trackId) {
  if (confirm('Remove this track from liked songs?')) {
    try {
      console.log('💔 Unliking track:', trackId);
      
      // Remove from liked tracks with all backups
      let likedTracks = JSON.parse(localStorage.getItem('hertzLikedTracks') || '{}');
      delete likedTracks[trackId];
      
      const dataString = JSON.stringify(likedTracks);
      localStorage.setItem('hertzLikedTracks', dataString);
      localStorage.setItem('hertzLikedTracks_backup', dataString);
      
      // Update offline tracks to mark as not liked
      let offlineTracks = JSON.parse(localStorage.getItem('hertzOfflineTracks') || '{}');
      if (offlineTracks[trackId]) {
        offlineTracks[trackId].isLiked = false;
        const offlineString = JSON.stringify(offlineTracks);
        localStorage.setItem('hertzOfflineTracks', offlineString);
        localStorage.setItem('hertzOfflineTracks_backup', offlineString);
      }
      
      // Trigger update for other tabs
      localStorage.setItem('hertzLikedTracksUpdate', Date.now().toString());
      
      console.log('✅ Track unliked successfully');
      showStatus('Track removed from liked songs', 'success');
      
      // Refresh display
      renderLikedTracks();
      
    } catch (error) {
      console.error('❌ Error unliking track:', error);
      showStatus('Error removing track', 'error');
    }
  }
}

// Player control functions
function playPause() {
  if (!allTracks[currentIndex]) {
    showStatus('No track selected', 'error');
    return;
  }
  
  if (isPlaying) {
    playerAudio.pause();
    playPauseBtn.innerHTML = '&#9654;';
    isPlaying = false;
    console.log('⏸️ Playback paused');
  } else {
    playerAudio.play().then(() => {
      playPauseBtn.innerHTML = '&#10073;&#10073;';
      isPlaying = true;
      console.log('▶️ Playback started');
    }).catch(error => {
      console.error('❌ Playback error:', error);
      showStatus('Playback failed: ' + error.message, 'error');
    });
  }
}

// Enhanced force rescan function with debugging
window.forceRescanTracks = async function() {
  console.log('🔍 Force rescanning for tracks...');
  showStatus('Force rescanning all storage locations...', 'info');
  
  // Clear current liked storage and rescan
  localStorage.removeItem('hertzLikedTracks');
  
  let foundTracks = 0;
  
  // Check offline tracks first
  try {
    const allOfflineTracks = JSON.parse(localStorage.getItem('hertzOfflineTracks') || '{}');
    const likedOfflineTracks = Object.values(allOfflineTracks).filter(track => 
      track.isLiked && track.mp3 && track.mp3.startsWith('data:audio')
    );
    
    if (likedOfflineTracks.length > 0) {
      const likedData = {};
      likedOfflineTracks.forEach(track => {
        likedData[track.id] = track;
      });
      localStorage.setItem('hertzLikedTracks', JSON.stringify(likedData));
      foundTracks = likedOfflineTracks.length;
      console.log(`✅ Found ${foundTracks} liked tracks in offline storage`);
    }
  } catch (error) {
    console.error('❌ Error scanning offline tracks:', error);
  }
  
  // Check backup sources if still no tracks
  if (foundTracks === 0) {
    const backupSources = [
      'hertzLikedTracks_backup',
      'hertzOfflineTracks_backup',
      'hertzOfflineTracks_auto_backup',
      'hertzOfflineTracks_exit_backup'
    ];
    
    for (const source of backupSources) {
      try {
        const backupData = JSON.parse(localStorage.getItem(source) || '{}');
        let tracks = [];
        
        if (source.includes('liked')) {
          tracks = Object.values(backupData).filter(track => track.mp3 && track.mp3.startsWith('data:audio'));
        } else {
          tracks = Object.values(backupData).filter(track => 
            track.isLiked && track.mp3 && track.mp3.startsWith('data:audio')
          );
        }
        
        if (tracks.length > 0) {
          const likedData = {};
          tracks.forEach(track => {
            likedData[track.id] = track;
          });
          localStorage.setItem('hertzLikedTracks', JSON.stringify(likedData));
          foundTracks = tracks.length;
          console.log(`✅ Found ${foundTracks} tracks in ${source}`);
          break;
        }
      } catch (error) {
        console.warn(`⚠️ Error checking ${source}:`, error);
      }
    }
  }
  
  if (foundTracks > 0) {
    renderLikedTracks();
    showStatus(`Found and restored ${foundTracks} liked tracks!`, 'success');
  } else {
    showStatus('No liked tracks found in any storage location', 'error');
  }
};

// Debug storage function
window.debugStorage = function() {
  console.log('🐛 STORAGE DEBUG REPORT');
  console.log('='.repeat(60));
  
  const sources = [
    'hertzLikedTracks',
    'hertzLikedTracks_backup',
    'hertzOfflineTracks',
    'hertzOfflineTracks_backup',
    'hertzOfflineTracks_auto_backup',
    'hertzOfflineTracks_exit_backup'
  ];
  
  sources.forEach(source => {
    try {
      const data = localStorage.getItem(source);
      if (data) {
        const parsed = JSON.parse(data);
        const values = Object.values(parsed);
        const withMp3 = values.filter(track => track.mp3 && track.mp3.startsWith('data:audio'));
        const liked = values.filter(track => track.isLiked);
        
        console.log(`📊 ${source}:`);
        console.log(`   - Total entries: ${values.length}`);
        console.log(`   - With valid MP3: ${withMp3.length}`);
        console.log(`   - Marked as liked: ${liked.length}`);
        console.log(`   - Storage size: ${(data.length / 1024).toFixed(1)}KB`);
        console.log(`   - Sample track:`, values[0]?.name || 'None');
      } else {
        console.log(`📊 ${source}: Empty`);
      }
    } catch (error) {
      console.log(`📊 ${source}: Error - ${error.message}`);
    }
  });
  
  console.log('='.repeat(60));
  showStatus('Debug info logged to console', 'info');
};

// Enhanced event listeners with error handling
if (playerAudio) {
  playerAudio.addEventListener('timeupdate', function() {
    if (playerAudio.duration) {
      progressBar.value = (playerAudio.currentTime / playerAudio.duration) * 100;
      currentTimeSpan.textContent = formatTime(playerAudio.currentTime);
      durationSpan.textContent = formatTime(playerAudio.duration);
    }
  });
  
  playerAudio.addEventListener('ended', function() {
    if (isLoop) {
      playerAudio.currentTime = 0;
      playerAudio.play();
    } else {
      playNext();
    }
  });
  
  playerAudio.addEventListener('error', function(e) {
    console.error('❌ Global audio error:', e);
    showStatus('Audio playback error', 'error');
  });
  
  playerAudio.volume = 0.7;
}

// Cleanup function to prevent memory leaks
window.addEventListener('beforeunload', function() {
  // Revoke any object URLs to prevent memory leaks
  if (playerAudio && playerAudio.src && playerAudio.src.startsWith('blob:')) {
    URL.revokeObjectURL(playerAudio.src);
  }
});

// Initialize on page load with delay for proper loading
window.addEventListener('DOMContentLoaded', function() {
  console.log('=== LIKED TRACKS PAGE LOADED ===');
  showStatus('Initializing liked tracks page...', 'info');
  
  setTimeout(() => {
    renderLikedTracks();
  }, 500);
});
  </script>
</body>
</html>